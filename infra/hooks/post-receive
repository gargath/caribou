#!/usr/bin/env ruby
#post receive

require 'fileutils'
require 'yaml'

unless File.exists?('hooks/config.yaml')
 puts "[FATAL] Config file not found."
 exit 255
end
config = YAML.load_file('hooks/config.yaml')

@DEPLOY_DIR = config['deploy_dir']
@STAGING_DIR = config['staging_dir']

old, @new, ref = ARGF.read.split " "

ref_type = `git cat-file -t #{ref}`
if ref_type.include? "commit"
  puts "[PRE-DEPLOY] Un-annotated tags are not eligible for deployment. Please tag with git tag [-a | -s]."
  puts "[PRE-DEPLOY] Nothing to deploy for this push."
  exit 1
end

tagname = ref.split('/')[-1]
if tagname.start_with? "staging"
  puts "[DEPLOY] Staging release."
  @TO_DIR = @STAGING_DIR
elsif tagname.start_with? "release"
  puts "[DEPLOY] Production release."
  @TO_DIR = @DEPLOY_DIR
else
  puts "[DEPLOY] Invalid tag name. Nothing to deploy."
  exit 1
end

if (@new =~ /^0*$/)
  if !File.exists?("#{@TO_DIR}/latest")
    puts "No current release. Unable to auto-rollback. Please cleanup deploy directory manually."
    exit 1
  end
  if !File.exists?("#{@TO_DIR}/previous")
    puts "Previous release does not exist. Unable to auto-rollback. Please clean up deploy directory manually."
    exit 1
  end

  previous_release = File.readlink("#{@TO_DIR}/previous")
  FileUtils::rm_rf("#{@TO_DIR}/latest")
  FileUtils::ln_s(previous_release, "#{@TO_DIR}/latest", :force => true)

  releases = Dir.glob("#{@TO_DIR}/*")
  releases.delete(previous_release)
  new_previous = releases.max_by { |f| f.length==40 ? File.ctime(f) : Time.new(0) }
  FileUtils::rm_rf("#{@TO_DIR}/latest")
  FileUtils::ln_s(new_previous, "#{@TO_DIR}/previous", :force => true)

  puts "Rollback complete. /latest is now #{previous_release.to_s.split('/')[-1]}, /previous is #{new_previous.to_s.split('/')[-1]}."
  exit 0
end

gitout = `git remote show origin 2>&1`
origin_name = gitout[/#{"Fetch URL: "}(.*?)#{"\n"}/m, 1].split("/")[-1]
@tmpdir = "/tmp/git/#{origin_name}/#{@new}"
FileUtils::mkdir_p(@tmpdir)
puts "[PRE-DEPLOY] Checking out your ref from origin #{origin_name} to #{@tmpdir}"

`GIT_WORK_TREE="#{@tmpdir}" git checkout -f -q #{@new}`
git_status = $?
if git_status.exitstatus != 0
  puts "[PRE-DEPLOY] Failed to check out code. Please make sure to push changes to origin before deploying."
  exit git_status.exitstatus
end
puts "[PRE_DEPLOY] Successfully checked out #{@new}"
Dir.chdir(@tmpdir) {
  tagname = ref.split('/')[-1]
  if tagname.start_with? "staging"
    puts "[DEPLOY] Deploying to staging."
    @TO_DIR = @STAGING_DIR
  elsif tagname.start_with? "release"
    puts "[DEPLOY] Deploying to production."
    @TO_DIR = @DEPLOY_DIR
  else
    puts "[DEPLOY] Invalid tag name. Nothing to deploy."
    exit 1
  end
  
  puts "[DEPLOY] Will deploy to #{@TO_DIR}"

  FileUtils::mkdir_p(@TO_DIR)
  FileUtils::cp_r(@tmpdir,@TO_DIR)
  FileUtils::rm_rf("#{@TO_DIR}/#{@new}/.git")
  FileUtils::rm_rf("#{@TO_DIR}/#{@new}/README.md")
  if File.exists?("#{@TO_DIR}/latest")
    previous = File.readlink("#{@TO_DIR}/latest")
    FileUtils::rm_rf("#{@TO_DIR}/previous")
    FileUtils::ln_s(previous, "#{@TO_DIR}/previous", :force => true)
  end
  FileUtils::rm_rf("#{@TO_DIR}/latest")
  FileUtils::ln_s("#{@TO_DIR}/#{@new}", "#{@TO_DIR}/latest", :force => true)
  FileUtils::rm_rf(@tmpdir)
  FileUtils::chmod(0666, "#{@TO_DIR}/#{@new}/data.json")
}
